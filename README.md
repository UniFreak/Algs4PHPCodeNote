# Code
```php
/**
 * p.1, t.2
 *
 * 成本模型
 *   两个空格
 */
```

it's computer science, so lgN means log base 2

没有将代码根据章节组织, 应该以 README 中的 @see 为导向

ClassMap?

API table

# TODO
- 表格?
- Math Expression: <https://github.com/leegao/readme2tex>
- _underscore_ not working in README.md
- fill @todo
- search @?
- wiki pages
- @see 图

# 基础

算法能在任何计算机上用任何语言实现
数据结构是算法的副产品或是结果
不应该使用资源消耗情况未知的算法

## 基础编程模型

编写递归代码注意:
- 递归总有一个**最简单的情况**
- 递归调用总是去尝试解决一个**规模更小**的子问题, 这样才能**收敛**最简单的情况
- 递归调用的父问题和尝试解决的子问题之间不应该有**交集**

while 循环中, 递增变量再循环结束之后仍然是可用的. 这个区别常常是使用 while 而非 for (不可用) 的主要原因

## 数据抽象

定义和使用数据类型, 这个过程也被称为**数据抽象**, 它是**函数抽象**风格的补充.
抽象数据类型 (ADT) 的主要不同之处在于将数据和函数的实现关联起来, 并将数据的表示方式隐藏起来

所有对象都有三大重要特性: 状态, 标识和行为

静态方法的主要作用是实现函数, 非静态(实例)方法的主要作用是实现数据类型的操作

## 背包, 队列和栈

理解链表是学习各种算法和数据结构中最关键的一步. 在结构化存储数据集时, 链表是数组的一种重要的替代方式.
不过链表编程也会遇到各种问题, 且调试十分困难

**链表**表示的是一列元素, 不同之处在于, 在链表中向序列插入或删除元素都更便捷:
- 从表头插入和删除结点都和链表长度无关
- 在其他位置的插入和删除操作和链表长度成正比. 标准解决方案是使用**双向链表**

链表的使用达到了我们的**对栈的**最优设计目标
- 可处理任意类型数据
- 所需空间和集合大小成正比
- 操作所需时间和集合大小无关

**背包**:一种不支持从中删除元素的集合数据类型, 迭代的顺序不确定且与用例无关.

**先进先出队列(队列)**:FIFO, 入列顺序和出列顺序相同

**下压栈(栈)**:LIFO, 入列顺序和出列顺序相反. 在计算机领域, 栈具有基础而深远的影响

使用栈进行算术表达式计算, 如 (1 + ( ( 2 + 3 ) * ( 4 * 5 ) )`:
1. 将操作数压栈
2. 将运算符压栈
3. 忽略左括号
4. 遇到右括号时, 弹出一个运算符, 弹出所需数量的操作数, 并将运算符和操作数的运算结果压入操作数栈 见 Evaluate.php

数组和链表这两种表示对象集合的方式, 常常被称为**顺序存储**和**链式存储**, 我们会在后面通过以下
方式扩展这两种基本数据结构:
- 扩展为含有多个链接的数据结构
- 扩展为复合型的数据结构, 如用背包存储栈, 用队列存储数组等

在研究一个新的应用领域时, 我们按以下步骤识别并使用数据抽象解决问题:
1. 定义 API
2. 根据特定应用场景开发用例代码
3. 描述一种数据结构(一组值的表示), 并在 API 所对应的抽象数据类型的实现中根据它定义类的实例变量
4. 描述算法(实现一组操作的方式), 并根据它实现类中的实例方法
5. 分析算法的性能特点

## 算法分析

性能问题:
- 程序会运行多长时间
- 会耗用多少内存

回答这些问题的过程的基础是_科学方法_.
我们会使用_数学分析_为算法成本建立简洁的模型, 并使用_实验数据_验证这些模型.

科学方法的一般过程
1. 细致_观察_真实世界, 精确测量
2. 根据观察结果提出_假设_模型
3. 根据模型_预测_未来的事件
4. 继续观察并_核实_预测的准确性
5. 如此反复直到确认预测和观察一致

科学方法的关键原则
- 设计的试验必须是_可重现_的, 这样他人也可自己验证假设
- 假设也必须是_可证伪_的, 这样我们才能确认某个假设是错误的

计算性任务的困难程度可以用_问题的规模_来衡量, 问题的规模可以是输入的大小或某个命令行参数.
如果运行时间和输入规模本身相对无关, 我们就需要进行一些试验来更好地理解并更好的控制运行时间对输入的敏感度.
你常常能在程序运行的时候就给出一个较为准确的预测 @see ThreeSum. 准确测量给定程序的运行时间是困难的,
但我们一般只需要近似值就可以了. 我们仍然需要准确的衡量来生成实验数据, 并根据它们得出并验证关于
程序运行时间和问题规模的假设 @see Stopwatch

假设: 幂次法则
使用 Stopwatch 测量 ThreeSum 的性能, 得到的图像符合**幂次法则**, 即 T(N)=aN^b 的猜想.
许多自然和人工的现象都符合幂次法则

Knuth 认为, 原则上我们可能构造出一个**数学模型**来描述任意程序的运行时间, 一个程序运行的总时间主要和两点有关:
- 执行每条语句的耗时
- 执行每条语句的频率

对于频率的分析, 一般会产生一个多项式, 一般次多项式中, 首项之后的其他项都相对较小,
我们常用 ~ 来忽略较小的项.
我们用 ~f(N) 表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数 (即随着 N 增大, ~f(N) 越来越近似于 f(N)).
用 g(N)~f(N) 表示 g(N)/f(N) 随着 N 的增大趋近于 1.
一般我们用到的近似方程都是 g(N)~af(N), 其中 f(N)=N^b(logN)^c, 其中 a, b, c 都是常数,
称 f(N) 为 g(N) 的**增长数量级**

对于程序运行时间的_猜想_很重要, 因为它将抽象世界的一个程序 和真实世界中运行它的一台计算机_联系_了起来;
_增长数量级_则让我们更进一步: 将程序和它实现的算法_隔离_开来, 这使我们对算法性能的知识可以应用于任何计算机

我们观察到一个关键现象是执行最频繁的指令决定了程序执行的总时间, 我们将这些指令成为程序的**内循环**

我们用**性质**表示需要用实验验证的_猜想_.
我们用**成本模型**评估算法的性质, 这个模型定义了算法中的基本操作, 如访问数组的次数.
我们用**命题**表示在某个成本模型下算法的_数学性质_
我们会研究算法准确的数学性质(命题)并对实现的性能做出猜想(性质), 并通过实验验证这些猜想

得到程序运行时间的数学模型所需的一般步骤如下:
1. 确定_输入模型_, 定义_问题规模_
2. 识别_内循环_
3. 根据内循环中的操作确定_成本模型_
4. 对于给定的输入, 判断这些操作的执行频率. 这可能需要进行_数学分析_

理解特定的数学模型对于理解基础算法的运行效率是很关键的

常见增长数量级的分类

|描述|数量级|典型代码|举例|备注|
|------|------|------|------|------|
|常数|1|普通语句|两数相加|
|对数|logN|二分策略|二分查找|对数的底数和增长的数量级无关, 因为不同底数仅相当于一个常数因子|
|线性|N|循环|找出最大元素|
|线性对数|NlogN|分治|归并排序|在实践中非常重要|
|平方|N^2|双层循环|检查所有元素对|
|立方|N^3|三层循环|检查所有三元组|
|指数|2^N|穷举|检查所有子集|非常慢, 不可能用于解决大规模问题, 但在算法理论仍有重要地位|

了解增长数量级的一个重要动力是帮助我们设计更快的算法, 比如如何优化 ThreeSum ?
- 先考虑问题的简化版本 @see TwoSum
- 使用已知的较快算法, 如归并排序(线性对数)和二分查找(对数) @see TwoSumFast

我们通常按以下方式解决各种新问题:
1. 实现并分析该问题的一种简单解法, 通常称其为**暴力**算法
2. 考察算法的各种改进, 它们通常能降低算法运行时间的增长数量级
3. 用实验证明新的算法更快
我们会学习同一个问题的多种算法, 因为对于实际问题来说, _运行时间只是选择算法所要考虑的因素之一_

倍率定理
: 如果 T(N)~aN^blgN, 那么 T(2N)/T(N)~2^b

通过**倍率试验**可以简单有效的预测大部分(对比值没有极限的算法无效)程序性能, 并判断其增长数量级:
1. 开发一个输入生成器来产生实际情况下的各种可能输入 (如 DoublingTest::timeTrail())
2. 运行 @see DoublingRatio, 计算每次试验和上次的运行时间比值
3. 反复运行直到该比值趋近于极限 2^b (倍率定理)
4. 则增长数量级约为 N^b (比如 T(N)~8=N^b, b=3)
5. 要预测一个程序的运行时间, 将上次观察到的时间乘以 2^b 并将 N 加倍, 如此反复
在性能压力的情况下应该考虑对编写过的所有程序进行倍率试验. 如果希望预测的输入规模不是 N 乘以 2,
则可以相应的调整这个比例

性能分析时产生误导性结果的原因, 有可能是
- 大常数: 我们忽略的常数可能很大, 要对大常数保持敏感
- 非决定性的内循环: 成本模型可能需要改进
- 指令时间: 每条指令执行时间总是相同的, 这个假设并不总是正确
- 系统因素: 系统中同时运行的其他程序应该是可以忽略或可以控制的
- 不分伯仲
- 对输入的强烈依赖: 注意输入应该和运行时间相对无关
    + 更小心的为问题的输入建模, 现有输入模型可能是不切实际的
    + 保证最坏情况下的性能, 如心脏起搏器
    + 随机化算法: 如 @see 快速排序中打乱输入, 以及 @see 散列算法
    + 考虑操作序列, 如压出栈的操作序列不同, 栈的性能可能也大不相同
    + 均摊分析: 将少量昂贵操作的成本通过大量廉价操作摊平 @? p.125
- 多个问题参量

算法分析者的任务就是尽可能地解释关于某个算法的更多信息, 而程序员的任务则是利用这些信息开发有效解决现实问题的程序

## 案例研究: union-find 算法

**动态连通性问题** @see UF
问题输入是一列整数对, 一对整数 p 和 q 代表 "p 和 q 相连". 目标是过滤掉序列中无意义的整数对
(两个整数均来自于同一个等价类中). 我们将对象称为 **触点**, 整数对称为 **连接**,
等价类称为 **连通分量** 或简称 **分量**

这个问题有很多现实应用, 如:
- 网络: 节点之间是否有连接? 电路触电是否相连? 社交网络中两个人是否有关系?
- 变量名等价性
- 数学集合: p 和 q 是否属于不同的数学集合?

设计算法时面对的第一个任务就是精确地定义问题

数据结构的性质将直接影响到算法的效率, 因此数据结构和算法的设计是紧密相关的

本书中研究各种基础问题时都会遵循的基本步骤:
1. 完整而详细的定义问题, 找出解决问题所必须的基本抽象操作并定义一份 API
2. 简介的实现一种初级算法, 给出一个精心组织的开发用例并使用实际数据作为输入
3. 当实现所能解决的问题的最大规模达不到期望时, 决定改进还是放弃
4. 逐步改进实现, 通过经验性分析或(和)数学分析验证改进后的效果
5. 用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
6. 如果可能尽量为最坏情况下的性能提供保证, 但在处理普通数据时也要有良好的性能
7. 在适当的时候将更细致的深入研究留给有经验的研究者并继续解决下一个问题


# 排序

学习排序算法三大意义:
1. 对排序算法的分析有助于全面理解比较算法性能的方法
2. 类似的技术也能有效解决其他类型的问题
3. 排序算法常常是解决其他问题的第一步

## 初级排序算法 @see Sort

学习这些初级算法的必要性:
- 它们帮助我们建立了一些基本的规则
- 它们展示了一些性能基准
- 在某些特殊情况下它们也是很好的选择
- 它们是开发更强大的排序算法的基石

选择排序 @see SelectionSort
插入排序 @see InsertionSort
希尔排序 @see ShellSort

只有研究那些最重要的算法的专家才会经历完整的研究过程, 但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程.
我们通过以下步骤比较两个算法:
1. 实现并调试它们
2. 分析它们的基本性质
3. 对它们的相对性能做出猜想
4. 用实验验证我们的猜想 @see SortCompare

## 归并排序

@see
- MergeSort
- TopDownMergeSort
- BottomUpMergeSort

不要对算法初始实现的性能盖棺定论

**分治思想**: 将大问题分割成小问题分别解决, 然后用所有小问题的答案来解决大问题

命题: 没有任何基于比较的算法能够保证使用少于 lg(N!)~NlgN (斯特灵公式) 次比较将长度为 N 的数组排序
证明: 任意基于比较的排序算法都对应着一颗高 h 的比较树, 而这个树叶子结点数量满足以下关系:
    N! <= 叶子结点数量 <= 2^h
    之所以至少有 N! 个, 是因为 N 个不同主键会有 N! 中不同排列, 如果少于 N!, 则肯定有遗漏
    之所以至多有 2^h 个, 是因为二叉树的性质
这是一个重要结论, 适用于任何能想到的基于比较的算法. 准确的上界为软件工程师保证性能提供了空间,
而准确的下界可以避免浪费时间在不可能的性能改进上

## 快速排序

@see
Sort
- SelectionSort
- InsertionSort
- MergeSort
    + TopDownMergeSort
    + BottomUpMergeSort
- ShellSort
- QuickSort
    + ThreeWayQuickSort

## 优先队列

**优先队列** 是一种_抽象数据类型_, 应该支持两种操作: _删除最大元素_ 和 _插入元素_

应用场景:
- 模拟系统: 事件的键即为发生的事件, 系统需要按时间顺序处理所有事件
- 任务调度: 键值对应的优先级决定了应该首先执行哪些任务
- 数值计算: 键值代表计算错误, 需要按照键值指定的顺序修正它们
- 排序: 通过插入一列元素然后一个个的删除其中最小的元素, 实现排序算法 @see 堆排序

实现栈或是队列与实现优先队列的最大不同在于对性能的要求

初级实现: _插入_和_删除最大元素_在最坏情况下需要_线性_时间
- 可以选择使用_基于数组的下压栈_或者_基于链表的下压栈_
- 可以选择使用_惰性方法_或者_积极方法_
    + 惰性方法: 插入时和入栈操作一样. 删除时用类似选择排序的内循环交换最大元素和边界元素, 然后删除
    + 积极方法: 插入时就利用插入排序, 使栈保持有序. 删除时则和出栈操作一样

基于堆的实现: 对数级别
- PQ
    + MaxPQ
    + MinPQ -> TopM
    + IndexMinPQ -> Multiway

**堆排序**: HeapSort


## 应用

|算法|稳定|原地|时间复杂度|空间复杂度|备注|
|------|------|------|------|------|------|
|选择|否|是|N^2|1|取决于输入元素的排列情况|
|插入|是|是|N~N^2|1|-|
|希尔|否|是|NlogN?~N^(6/5)?|1|-|
|快速|否|是|NlogN|lgN|运行效率有概率提供保证|
|三向快速|否|是|N~NlogN|lgN|运行效率有概率保证, 同时也取决于输入元素的分布情况|
|归并|是|否|NlogN|N|-|
|堆|否|是|NlogN|1|-|


排序应用一览
- 商业计算
- 信息搜索: 有序能确保使用经典的二分查找算法
- 运筹学: 调度, 负载均衡
- 事件驱动模拟 @see c.6.0.1
- 数值计算: 使用优先队列和排序控制计算中的精确度
- 组合搜索: A* 算法
- Prim / Dijkstra / Kruskal / 霍夫曼压缩 / 字符串处理

# 查找

## 符号表

**符号表 (Symbol Table)**: 是一种存储键值对的数据结构, 支持两种操作: _插入(put)_, 即将一组新的键值对存入表中;
    _查找(get)_, 即根据给定的键得到相应的值
**有序符号表**: 会保持_键的有序_的符号表

设计决策
- 重复的键. 这些规则定义了**关联数组**的抽象形式
    + 每个键只对应着一个值 (表中不允许存在重复的键)
    + 当用例代码向表中存入的键值对和表中已有的键 (及关联的值) 冲突时, 新的值会替代旧的值
- 键和值都不能为 null
- 删除的实现可以有两种方法: _延时删除_或_即时删除_. 本书的实现采用即时删除
- 我们定义了 keys() 方法返回一个 Iterable 对象以方便用例遍历所有的键, 这么做是为了和以后的有
  序符号表的所有方法保持一致
- 为了维护_对象等价性_, 最好使用不可变的数据类型作为键, 否则表的一致性是无法保证的

查找的成本模型
- 统计_比较_的次数 (等价性测试或是键的相互比较)
- 在内循环不进行比较 (极少) 的情况下, 统计_数组的访问次数_

用例约定
- 在用例代码中, 除非想使用一个特定的实现, 否则都会使用 ST 表示一个符号表实现
- @todo 行为测试用例 S 是键, 0 是值. 键可以是任何可比较的数据类型, 不要局限于数值
- @todo 性能测试用例 FrequencyCounter -> 评估两种初级的符号表实现

实现
- 基于链表的_顺序查找_ (一个一个地顺序遍历符号表中的所有键并测试是否相等来寻找与被查找键匹配的键)
  @see SequentialSearchST
- 基于有序数组的_二分查找_ @see BinarySearchST

性能分析
- 比分析排序更困难, 因为不同的用例所进行的操作序列各不相同
- 但它们的使用肯定不是随机的, _因此我们主要研究最坏情况下的性能_
- _命中_表示一次成功的查找, _未命中_表示一次失败的查找

由于 PHP 语言限制: 没有泛型, 没有 Comparable 接口, 没有私有类
- equals() 用 == 代替
- 私有类放到一个文件内
- PHP 中, 0 == null, 所以这里一定要用全等

符号表各种实现的优缺点:

|数据结构|实现|优点|缺点|
|------|------|------|------|
|链表(顺序查找)|SequentialSearchST|适用于小型问题|对于大型符号表很慢|
|有序数组(二分查找|BinarySearchST|最优的查找效率和空间需求, 能进行有序性操作|插入操作很慢|
|二分查找树|BST|实现简单, 有序性操作|没有性能上界保证, 额外空间|
|平衡二叉查找树|RedBlackBST|最优的查找和插入效率, 有序性操作|额外空间|
|散列表|SeparateChainHashST<br/>LinearProbingHashST|快速查找和插入常见类型的数据|需计算散列, 无法进行有序性操作, 额外空间|

## 二叉查找树

将链表插入的灵活性和有序数组查找的高效性结合起来. 具体来说, 就是使用每个结点含有_两个_链接
(链表中每个结点只含有一个链接)

我们所使用的的数据结构由**结点**组成, 结点包含的**链接**可以为空 (null) 或者指向其他结点. 在
**二叉树**中, 每个结点只能有一个父结点 (**根节点**例外, 它没有父节点), 而且每个结点都只有左右
两个链接, 分别指向自己的**左子结点**和**右子结点**. 一颗**二叉查找树(BST)**是一颗二叉树, 其中
每个结点都含有一个可比较的键(以及相关联的值), 且每个节点的键都大于其左子树中的任意结点的键而小于
右子树的任意结点的键

## 平衡查找树


一颗**2-3查找树**或为一颗空树, 或由以下结点组成:
- **2-结点**, 含有一个键(及其对应的值)和两条链接, 左链接指向的 2-3 树中的键都小于该结点,
  右链接指向的 2-3 树中的键大于该结点
- **3-结点**, 含有两个键(及其对应的值)和三条链接, 左链接指向的 2-3 树中的键都小于该结点, 中链接指向
  指向的 2-3 树中的键都位于该结点的两个键之间, 右链接指向的 2-3 树中的键都大于该结点
和以前一样, 将指向一棵空树的链接称为**空连接**. 一颗**完美平衡**的 2-3 查找树中的所有空链接
到根节点的距离应该是相同的. 我们用 _2-3 树_ 指代一颗完美平衡的 2-3 查找树

2-3 树的分析和二叉查找树的分析大不相同, 我们主要感兴趣的是_最坏情况下_的性能, 而非_一般情况_ (这种
情况下我们会用随机键模型分析预期的性能)

命题 p.273
- F: 在一颗大小为 N 的 2-3 树中, 查找和插入操作访问的结点必然不超过 lgN 个
  证明: 一个含有 N 个结点的 2-3 树的高度在 ⌊log₃N⌋=⌊(lgN)/(lg3)⌋ (如果树中全是 3-结点) 和
  ⌊lgN⌋ (如果树中全是 2-结点) 之间

操作步骤 @todo?

尽管可以用不同的数据类型表示 2-结点和 3-结点, 但这种直白的表示方法实现大多数的操作并不方便, 因为
需要处理的情况太多. 这种实现所产生的的额外开销可能会使算法比标准的二叉查找树更慢. 因此引入
**红黑二叉查找树**数据结构来表达并实现它

**红黑二叉查找树**基本思想是用标准的二叉查找树 (完全由 2-结点构成) 和一些额外的信息 (替换 3-结点)
来表示 2-3 树. 我们将树中的链接分为两种类型: **红链接**将两个 2- 结点连接起来构成一个 3-结点,
**黒链接**则是 2-3 树中的普通链接. 即将一个 3-结点表示如下 (`//` 代表红链接).

        a  b                              b
      /   |  \                          //  \
    <a   a~b  >b       --->            a    >b
                                     /  \
                                    <a  a~b

用这种方式表示 2-3 树的二叉查找树称为 **红黑二叉树查找树** (简称 **红黑树**). 可以看到, 将红链接
画平时, 一颗红黑树就是一颗 2-3 树. 红黑树既是二叉查找树, 也是 2-3 树. 它将二叉查找树中简洁高效的
查找方法和 2-3 树中高效的平衡插入算法结合了起来

## 散列表

使用散列表的查找算法分两步:
1. 用_散列函数_将被查找的键转化为数组的一个索引
2. _处理碰撞冲突_: _拉链法_ @see SeparateChianingHashST 和_线性探测法_ @see LinearProbingHashST

散列表是算法在_时间和空间上做出权衡_的经典例子. 散列表使用了适度的空间和时间并在这两个极端之间找到
了一种平衡. 我们不必重写代码, 只需调整散列算法的参数就可以在空间和时间之间做出取舍. 使用散列表, 可
以实现在一般应用中拥有 (均摊后) _常数级别_的查找和插入操作的符号表. 这使得它在很多情况下成为简单
符号表的最佳选择

_散列函数_应该易于计算并能够均匀分布所有的键. 散列函数和键的类型有关, 严格地说, 对于每种类型的键
都需要一个与之对应的散列函数. 例如
- 形如 123-45-6789 的社会保险号: 用所有 9 个数字得到一个整数, 再考虑整数的散列函数
- 正整数: 最常用方法是_除留余数法_, 如果使用素数, 散列值的分布会更好
- 浮点数 (0~1 之间的实数): 将键表示为二进制数然后再使用除留余数法
- 字符串: 将字符串当做一个 N 位的 R 进制值, 然后使用 _Horner方法_

    ```php
    $hash = 0;
    for ($i = 0; $i < mb_strlen($s); $i++) {
        // 获取字符对应的数值
        $ord = mb_ord(mb_substr($s, $i, 1));
        // R 需要足够小, 不造成溢出
        // M 使用较小的素数, 能保证所有字符都能发挥作用
        $hash = ($R * $hash + $ord) % $M;
    }
    ```

- 组合键: 比如含有几个整型域的 Date

    ```php
    $hash = ((($this->day * $R + $this->month) % $M) * $R + $this->year) % $M;
    ```

如果散列值的计算很耗时, 可以考虑使用**软缓存**, 比如将每个键的散列值在第一次计算之后存入 hash 变量

优秀的散列方法需要满足三个条件:
- _一致性_ -- 等价的键必然产生相等的散列值
- _高效性_ -- 计算便捷
- _均匀性_ -- 均匀地散列所有的键
糟糕的散列函数经常是性能问题的罪魁祸首, 在有性能要求时应该谨慎使用散列, 并且测试所使用的所有散列函数,
以知道计算散列函数和比较两个键, 哪个耗时更多

设计散列函数时, 应尽量避免随意指定参数以防止大量的碰撞

假设 p.296
- J (均匀散列假设): 我们使用的散列函数能够均匀平独立的将所有的件散布于 0 到 M-1 之间
  讨论: 理论研究告诉我们想要找到一个计算简单但又能拥有一致性和均匀性的散列函数是不太可能的. 实际
  应用中, 大多数程序员会满足于随机数生成器类的散列函数. 很少有人会去检验独立性, 而这个性质一般不
  会满足

在实践中, 两种方法在内存使用上的差别主要是因为拉链法为每个键值对都分配了一小块内存, 而线性探测则为整张表
使用了两个很大的数组.

令 α=N/M, 则在拉链法中, α 是每条链表的长度, 在线性探测法中, α 是已被占用的空间的比例, 称为_使用率_

散列后键的顺序信息就丢失了, 如果需要有序性相关的操作, 散列表不是合适的选择. 在键的顺序并不重要的应用中,
它可能是最快的 (也是使用最广泛的) 的符号表实现

## 应用

每当使用一个名称来指代某种东西时, 都用到了符号表

对于典型的应用程序, 应该在散列表和二叉查找树之间进行选择
- 散列表的代码更简单, 查找时间最优
- 二叉查找树抽象结构更简单
- 红黑树可保证最坏情况性能, 支持有序性操作
多数程序员第一选择都是散列表, 在其他因素更重要时才选择红黑树

SET: 无需处理具体值, 只需检测键在表中是否存在. 分为有序和无序两个版本. 用例
- DeDup: 去掉输入流中重复项
- WhiteFilter: 好友列表; BlackFilter: 垃圾邮件

字典类应用: 每个键都有一个与之关联的值 @see LookupIndex

|应用|键|值|
|------|------|------|
|电话黄页|人名|电话号码|
|字典|单词|定义|
|账户信息|账号|余额|
|基因组|密码子|氨基酸|
|实验数据|数据/时间|实验结果|
|编译器|变量名|内存地址|
|文件共享|歌曲名|计算机|
|DNS|网站|IP 地址|

索引类应用: 一个键和多个值相关联的符号表 @see FileIndex

|应用|键|值|
|------|------|------|
|基因组学|氨基酸|一系列密码子|
|商业交易|账号|一系列交易|
|网络搜索|关键字|一系列网页|
|IMDB|电影|一系列演员|

**反向索引**: 用值来查找键的操作

**稀疏向量**: @see SparseVector


@todo
- SET, HashSET p.314
- Dedup, WhiltFilter p.315
- LookupCSV p.318
- LookupIndex p.321
- FileIndex p.322





