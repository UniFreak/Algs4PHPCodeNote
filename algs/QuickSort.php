<?php
namespace Algs;

/**
 * p.182, p.184
 *
 * 快速排序: 由 C.A.R Hoare 在 1960 年发明
 * 递归地将子数组 a[lo..hi] 排序. 先用 partition() 将 a[j] 放入合适位置, 然后再递归调用将其他位置元素排序
 *
 * 目前学过的算法中, 这是第一个能下面两个优点结合起来的排序算法
 * - 原地排序 (只需要一个很小的辅助栈)
 * - 所需时间和 NlgN 成正比
 *
 * 快速排序的关键在于 **切分**, 这个过程使得数组满足下面三个条件: @see partition()
 * 1. 对于某个 j, a[j] 已经排定
 * 2. a[lo] 到 a[j-1] 中的所有元素都不大于 a[j]
 * 3. a[j+1] 到 a[hi] 中的所有元素都不小于 a[j]
 *
 * 但是它非常脆弱, 在实现时, 要非常小心的才能避免错误和低劣的性能
 * - 使用辅助数组也很容易实现切分, 但是开销很大. 如果将空数组创建在递归的切分方法中, 会大大降低排序速度
 * - 如果切分元素刚好是数组中最大或最小的元素, 以及数组中可能包含和切分元素值相同的元素这两种情况.
 *   注意避免扫描指针越界, 或没有正确终止循环和递归
 * - 保持随机能消除输入对性能的影响. 除了本例中的随机实现, 也可以在 partition() 中随机选择一个切分元素实现
 * - 本实现中, 左侧扫描遇到大于_等于_就停下, 右侧遇到小于_等于_就停下. 虽然这样做会导致不必要的等值交换,
 *   但在某些典型情况下, 会避免算法的运行时间变为平方级别
 *
 * 快速排序和归并排序 (@see MergeSort) 是互补的:
 * - 归并排序: 一个数组被等分成两半, 将子数组分别排序, 并将有序的子数组归并以将整个数组排序
 * - 快速排序: 切分的位置取决于数组的内容, 当两个子数组都有序时, 整个数组也就自然有序了
 *
 * 本实现的运行时间在 1.39NlgN 的某个常数因子的范围内.
 * 归并排序也能做到这一点, 但一般来说快速排序更快 (尽管它的比较次数多 39%), 因为它移动数据的次数更少
 *
 * 命题
 * - 将长度为 N 的无重复数组排序, 快速排序平均需要 ~2NlnN 次比较 (以及 1/6 的交换)
 * - 快速排序最多需要约 N^2/2 比较, 但随机打乱数组能够预防这种情况
 *   证明略 @see p.186
 *   
 * 性质
 * - T: 快速排序是最快的通用排序算法
 *
 * 改进思路
 * - 排序小数组 (比如 5~15 个元素) 时切换到插入排序
 * - 使用子数组的一小部分元素的中位数来切分数组. 
 *   比如三取样切分: 将取样大小设为 3 并用大小居中的元素进行切分
 * - 可以将取样元素放在数组末尾作为 "哨兵" 来去掉数组边界测试
 * - 对于含有大量重复元素的数组, 考虑使用 **三向切分** @see ThreeWayQuickSort
 */
class QuickSort extends Sort
{
    public static function sort(array &$a): void
    {
        StdRandom::shuffle($a); // 消除对输入的依赖
        self::doSort($a, 0, count($a)-1);
    }

    private static function doSort(array &$a, int $lo, int $hi): void
    {
        if ($hi <= $lo) {
            return;
        }
        $j = self::partition($a, $lo, $hi);
        self::doSort($a, $lo, $j-1);
        self::doSort($a, $j+1, $hi);
    }

    private static function partition(array &$a, int $lo, int $hi): int
    {
        $i = $lo; $j = $hi+1;   // 左右扫描指针. 注意: 是 hi+1, 而不是 hi, 以让后续的 --j 运行正确
        $v = $a[$lo];           // 切分元素
        while (true) {          // 扫描左右, 检查扫描是否结束并交换元素
            while (self::less($a[++$i], $v)) if ($i == $hi) break; // 找到左边较大元素
            while (self::less($v, $a[--$j])) if ($j == $lo) break; // 找到右边较小元素
            if ($i >= $j) break;
            self::exch($a, $i, $j);                                // 交换位置
        }
        self::exch($a, $lo, $j); // 将 v 放入正确位置 j
        return $j;               // a[lo..j-1] <= a[j] <= a[j+1..hi] 达成
    }
}