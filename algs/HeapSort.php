<?php
namespace Algs;

/**
 * p.206
 *
 * 堆排序: 将所有元素插入一个查找最小元素的优先队列, 然后再重复调用_删除最小元素_的操作来将它们按顺序删去
 *   - 它是我们所知的唯一能够同时最优的利用空间和时间的方法
 *   - 但现代系统的许多应用很少使用它, 因为它无法利用缓存, 元素很少和相邻的其他元素进行比较
 *   - 另一方面, 用堆实现的优先队列在现代应用程序中越来越重要 @see PQ
 *
 * 可分为两个阶段
 *   1. _堆的构造_阶段: 将原始数组重新组织安排进一个堆中 (可以将需要排序的数组本身作为堆)
 *       - 可以从左到右遍历数组, 用 swim() 保证扫描指针左侧所有元素已经是一颗堆有序的完全树 (NlogN)
 *       - 更高效的办法是从右至左, 用 sink() 构造子堆: 把每个位置的元素看做已经是一个子堆的根结点 -- 如果
 *         一个结点的两个子结点都已经是堆了, 那么在该结点上调用 sink() 可以将它们变成一个堆. 如此递归地
 *         建立起堆的秩序. 只需要扫描数组中的一半元素, 因为可以跳过大小为 1 的子堆
 *   2. _下沉排序_阶段: 从堆中按递减顺序取出所有元素并得到排序结果
 *
 * 命题
 *   - R: 用下沉操作由 N 个元素构造堆只需少于 2N 次比较以及少于 N 次交换
 *     证明: 观察可知, 构造过程中处理的堆都较小. 例如, 要构造一个 127 个元素的堆, 会处理 32 个 大小为 3 的堆,
 *     16 个大小为 7 的堆, 8 个大小为 15 的堆, 4 个大小为 31 的堆, 2 个大小为 63 的堆和 1 个大小为 127 的堆,
 *     因此 (最坏情况下) 需要 32*1 + 16*2 + 8*3 + 4*4 + 2*5 + 1*6 = 120 次交换,
 *     以及两倍的比较 (sink() 的比较次数为 2logN)
 *   - S: 堆排序只需少于 (2NlgN+2N) 次比较 (以及一半次数的交换)
 *     证明: 2N 来自于堆的构造 (@see R), 2NlgN 来自于每次下沉操作最大可能需要 2lgN 次比较 (@see PQ:R,Q)
 *
 * 改进思路
 *   - Floyd 1964: 在下沉中总是直接提升较大的子结点到达堆底, 然后再使元素上浮到正确位置. 这个想法
 *     几乎可以将比较次数减少一半 -- 接近了归并排序所需的比较次数. 但需要额外的空间, 因此实际应用中
 *     只有当比较操作代价较高时才有用 (比如排序键值较长类型的元素)
 */
class HeapSort extends Sort
{
    public static function sort(array &$a): void
    {
        $N = count($a);
        // 构造阶段: 先构造大数优先的堆 
        // 把右一半元素看成已经是子堆的根结点, 递归的对其两两子堆的父结点调用 sink() 构建堆秩序
        for ($k = (int) ($N / 2); $k >= 1; $k--) {
            self::sink($a, $k, $N);
        }
        // 下沉排序阶段: 然后依次跟最后一个元素交换, 相当于把大数从右到左依次排定 (最终数组按从小到大排定)
        // N-- 相当于删除最大元素的操作
        while ($N > 1) {
            self::exch($a, 1, $N--);
            self::sink($a, 1, $N);
        }
    }

    private static function sink(array &$a, int $k, int $N)
    {
        while (2 * $k <= $N) {
            $j = 2 * $k;
            if ($j < $N && self::less($a[$j-1], $a[$j])) $j++;
            // 因为 sort 中父子结点关系的前提是数组以 1 开头, 故这里调用 less 时, 比较的是 $k-1, $j-1
            if (! self::less($a[$k-1], $a[$j-1])) break;
            self::exch($a, $k, $j);
            $k = $j;
        }
    }

    protected static function exch(array &$a, int $i, int $j): void
    {
        // 因为 sort 中父子结点关系的前提是数组以 1 开头, 故这里交换元素时, 交换的是 $k-1, $j-1
        $i--; $j--;
        $t = $a[$i];
        $a[$i] = $a[$j];
        $a[$j] = $t;
    }
}